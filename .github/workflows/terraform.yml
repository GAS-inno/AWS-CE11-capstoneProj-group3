name: Terraform Infrastructure

on:
  push:
    branches: 
      - "main"
      - "feature/ysim"
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform.yml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
  pull_request:
    branches: [ "main" ]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform.yml'

env:
  AWS_REGION: us-east-1
  TF_VERSION: "1.5.0"

permissions:
  contents: read
  pull-requests: write

jobs:
  # CI job for pull requests - validation and security checks only
  ci:
    name: Terraform CI
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Verify Terraform Directory
      run: |
        echo "Current directory: $(pwd)"
        echo "Listing workspace:"
        ls -la
        echo "Checking terraform directory:"
        ls -la terraform/
        echo "Terraform directory exists: $(test -d terraform && echo 'YES' || echo 'NO')"

    - name: Terraform Format Check
      run: cd terraform && terraform fmt -check

    - name: Terraform Init
      run: cd terraform && terraform init

    - name: Terraform Validate
      run: cd terraform && terraform validate

    - name: Setup TFLint
      uses: terraform-linters/setup-tflint@v3
      with:
        tflint_version: latest

    - name: Init TFLint
      run: cd terraform && tflint --init

    - name: Run TFLint
      run: cd terraform && tflint -f compact

    # Temporarily disabled - may be causing path issues
    # - name: Checkov Security Scan
    #   uses: bridgecrewio/checkov-action@master
    #   with:
    #     framework: terraform
    #     directory: terraform

    - name: Terraform Plan (PR)
      run: cd terraform && terraform plan -no-color -input=false

  # Auto-apply on push to main or feature/ysim
  apply:
    name: Terraform Apply & Deploy
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/feature/ysim')

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false

    - name: Terraform Init
      run: cd terraform && terraform init

    - name: Terraform Plan
      run: cd terraform && terraform plan -no-color -input=false -out=tfplan

    - name: Terraform Apply
      run: cd terraform && terraform apply -auto-approve tfplan

    - name: Get AWS Account ID
      id: aws-account
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
        echo "AWS Account ID: $ACCOUNT_ID"

    - name: Get ECR Repository URL
      id: ecr
      run: |
        cd terraform
        ECR_URL=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
        if [ -z "$ECR_URL" ]; then
          ECR_URL="${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/ce11g3-sky-high-booker"
        fi
        echo "ecr_url=$ECR_URL" >> $GITHUB_OUTPUT
        echo "ECR URL: $ECR_URL"

    - name: Install Lambda Dependencies
      run: |
        echo "üì¶ Installing Lambda dependencies..."
        cd lambda/bookings
        npm install --production
        cd ../..

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build Docker Image
      run: |
        echo "üê≥ Building Docker image..."
        docker build -t sky-high-booker:latest .
        docker tag sky-high-booker:latest ${{ steps.ecr.outputs.ecr_url }}:latest
        docker tag sky-high-booker:latest ${{ steps.ecr.outputs.ecr_url }}:${{ github.sha }}

    - name: Push Docker Image to ECR
      run: |
        echo "üì§ Pushing Docker image to ECR..."
        docker push ${{ steps.ecr.outputs.ecr_url }}:latest
        docker push ${{ steps.ecr.outputs.ecr_url }}:${{ github.sha }}

    - name: Get ECS Cluster and Service Info
      id: ecs-info
      run: |
        cd terraform
        CLUSTER_NAME=$(terraform output -raw ecs_cluster_name 2>/dev/null || echo "ce11g3-ecs-cluster")
        SERVICE_NAME=$(terraform output -raw ecs_service_name 2>/dev/null || echo "sky-high-booker")
        echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
        echo "ECS Cluster: $CLUSTER_NAME"
        echo "ECS Service: $SERVICE_NAME"

    - name: Force ECS Service Update
      run: |
        echo "üîÑ Updating ECS service with new Docker image..."
        aws ecs update-service \
          --cluster ${{ steps.ecs-info.outputs.cluster_name }} \
          --service ${{ steps.ecs-info.outputs.service_name }} \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}

    - name: Wait for ECS Service Stability
      run: |
        echo "‚è≥ Waiting for ECS service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ steps.ecs-info.outputs.cluster_name }} \
          --services ${{ steps.ecs-info.outputs.service_name }} \
          --region ${{ env.AWS_REGION }}
        echo "‚úÖ ECS service is now stable!"

    - name: Terraform Output
      run: |
        cd terraform
        echo "## üéâ Terraform Apply & Deployment Successful!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üèóÔ∏è AWS Resources Created/Updated" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Cognito User Pool & Client (Authentication)" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ DynamoDB Tables (flights, bookings, payments, user-profiles)" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ API Gateway REST API" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ S3 Bucket (static assets)" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ ECS Fargate Cluster with ALB" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ ECR Repository" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Lambda Functions (Booking APIs)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üê≥ Docker Deployment" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Docker image built successfully" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Image pushed to ECR: \`${{ steps.ecr.outputs.ecr_url }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ ECS service updated with new image" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Image tags: \`latest\`, \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìã Terraform Outputs" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
        terraform output -json >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üåê Application URLs" >> $GITHUB_STEP_SUMMARY
        APP_URL=$(terraform output -raw application_url 2>/dev/null || echo "N/A")
        API_URL=$(terraform output -raw api_gateway_url 2>/dev/null || echo "N/A")
        echo "- **Application**: $APP_URL" >> $GITHUB_STEP_SUMMARY
        echo "- **API Gateway**: $API_URL" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ‚ú® Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "Your application has been deployed and is now running on ECS Fargate." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìù Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Access your application using the URL above" >> $GITHUB_STEP_SUMMARY
        echo "2. Monitor ECS service health in AWS Console" >> $GITHUB_STEP_SUMMARY
        echo "3. Check CloudWatch logs for any issues" >> $GITHUB_STEP_SUMMARY

  # Infrastructure job for manual deployments
  terraform:
    name: Terraform ${{ github.event.inputs.action || 'Manual' }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    if: github.event_name == 'workflow_dispatch'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Format Check
      id: fmt
      run: cd terraform && terraform fmt -check
      continue-on-error: true

    - name: Terraform Init
      id: init
      run: cd terraform && terraform init

    - name: Terraform Validate
      id: validate
      run: cd terraform && terraform validate -no-color

    - name: Terraform Plan
      id: plan
      if: github.event.inputs.action == 'plan' || github.event.inputs.action == 'apply'
      run: |
        cd terraform
        terraform plan -no-color -input=false \
          -var="environment=${{ github.event.inputs.environment }}" \
          -out=tfplan
      continue-on-error: true

    - name: Update Pull Request with Plan
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request' && (github.event.inputs.action == 'plan' || github.event.inputs.action == 'apply')
      env:
        PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const output = `#### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
          #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
          #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
          #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`
          
          <details><summary>Show Plan</summary>
          
          \`\`\`\n
          ${process.env.PLAN}
          \`\`\`
          
          </details>
          
          *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })

    - name: Terraform Plan Status
      if: steps.plan.outcome == 'failure'
      run: exit 1

    - name: Terraform Apply
      if: github.event.inputs.action == 'apply'
      run: cd terraform && terraform apply -auto-approve tfplan

    - name: Terraform Destroy Plan
      if: github.event.inputs.action == 'destroy'
      run: |
        cd terraform
        terraform plan -destroy -no-color -input=false \
          -var="environment=${{ github.event.inputs.environment }}" \
          -out=destroy-plan

    - name: Terraform Destroy
      if: github.event.inputs.action == 'destroy'
      run: cd terraform && terraform apply -auto-approve destroy-plan

    - name: Output Terraform Results
      if: github.event.inputs.action == 'apply'
      run: |
        cd terraform
        echo "üéâ Terraform ${{ github.event.inputs.action }} completed successfully!"
        echo "üìã Infrastructure Summary:"
        terraform output -json | jq -r 'to_entries[] | "\(.key): \(.value.value)"'